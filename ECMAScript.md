**ECMAScript函数**
- 1.一个重要特点：	命名的参数只提供便利，但不是必须的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与签名一致，但是在ECMAScript中没有这些条条框框，解析器不会验证命名参数。
- 2.无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
- 3.实际上，未指定返回值的函数返回的是一个特殊的undefined值。
- 4.ECMAScript中没有函数签名的概念，因此其函数参数是一个包含零或多个值的数组的形式传递的。
- 5.可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
- 6.由于不存在函数签名的特性，ECMAScript函数不能重载。
**变量、作用域和内存问题**
- javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已，由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值和其数据类型可以在脚本的生命周期内改变。
- 1.基本类型和引用类型的值
	+ Undefined、Null、Boolean、Number、String,这五种基本数据类型是按值访问的，因为可以操作保存在变量中实际的值。
	+ 引用类型的值是保存在内存当中的对象，JavaScript不能直接操作对象的内存空间，实际上是在操作对象的引用而不是实际的对象，引用类型的值是按引用访问的。
	+ ECMAScript中所有函数的参数都是按值传递的。
	+ 检测类型 typeof instanceof
- 2.执行环境及作用域
	+ 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或者浏览器——时才会被销毁）
	+ 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
	+ 执行环境的类型只有两种————全局和局部（函数）
	+ 延长作用域链 try-catch语句的catch块；with语句。这两个语句都会在作用域的前端添加一个变量对象，对于with语句来说，会将指定的对象添加到作用域链中。对于catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象声明。
	+ 没有块级作用域
- 3.垃圾收集——JavaScript具有自动垃圾收集机制
	+ 这种垃圾收集机制的原理其实很简单：找出那些不在继续使用的变量，然后其占用的内存。为此垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性的执行这一操作。
	+ 具体在浏览器中使用有两种策略 标记清除 引用计数
	+ **标记清除**：这是 JavaScript 中最常见的垃圾回收方式。为什么说这是种最常见的方法，因为从 2012 年起，所有现代浏览器都使用了标记-清除的垃圾回收方法，除了低版本 IE...它们采用的是引用计数方法。

		那什么叫标记清除呢？JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象...对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。

		标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。

		2012 年起，所有现代浏览器都使用了这个方法，所有的改进也都是基于这个方法，比如标记-整理方法。

		标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。
	+ **引用计数**: 在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：
	``
	let obj1 = { a: 1 }; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 
	let obj2 = obj1; // A 的引用个数变为 2
	obj1 = 0; // A 的引用个数变为 1
	obj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了``
	但是引用计数有个最大的问题： 循环引用。
	``function func() {
    let obj1 = {};
    let obj2 = {};
    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}``
	当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。
	要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：
	``obj1 = null;
obj2 = null;``
	+ **内存泄漏**：内存泄漏是指计算机可用的内存越来越少，主要是因为程序不能释放那些不再使用的内存。
	+ **良好实践**
		1、优化内存的一个最好的衡量方式就是只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null，这上面说过，叫“解除引用”。需要注意的是，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收。

		在内存泄漏部分，我们讨论了无意的全局变量会带来无法回收的内存垃圾。但有些时候，我们会有意识地声明一些全局变量，这个时候需要注意，如果声明的变量占用大量的内存，那么在使用完后将变量声明为 null。

		2、减少内存垃圾的另一个方法就是避免创建对象。new Object() 是一个比较明显的创建对象的方式，另外 const arr = [];、const obj = {};也会创建新的对象。另外下面这种写法在每次调用函数时都会创建一个新的对象：
		``function func() {
    return function() {};
}``
		另外，当清空一个数组时，我们通常的做法是 array = []，但这种做法的背后是新建了一个新的数组然后将原来的数组当作内存垃圾。建议的做法是 array.length = 0，这样做不仅可以重用原来的变量，而且还避免创建了新的数组。